# The SSH Key Problem in HPC

> **TL;DR**: HPC clusters distribute static SSH keys to every node. These keys sit
> unprotected on disk, never expire, and provide lateral movement if compromised.
> Hardware-bound credentials solve this.

## The Current State

### How MPI Clusters Handle SSH

```
Cluster Setup Day 1:
┌──────────────┐
│  Admin       │
│  generates   │──► id_rsa + id_rsa.pub
│  keypair     │
└──────────────┘
       │
       ▼
┌──────────────────────────────────────────────────────┐
│  Copy private key to:                                │
│  - Head node (~/.ssh/id_rsa)                         │
│  - All compute nodes (~/.ssh/id_rsa)                 │
│  - Shared filesystem (/home/user/.ssh/id_rsa)        │
│  - Backup systems                                    │
│  - Container images                                  │
│  - VM templates                                      │
└──────────────────────────────────────────────────────┘
       │
       ▼
   Key now exists in 100+ locations
   Key never expires
   Key never rotates
   Key has no hardware binding
```

### Where SSH Keys End Up

| Location | Risk |
|----------|------|
| User home directories | Readable by compromised processes |
| NFS/Lustre shared storage | One breach exposes all keys |
| Ansible/Puppet repos | Checked into version control |
| Container images | Baked into layers, never rotated |
| VM snapshots | Persist across instance lifecycles |
| Backup tapes | Exist for years, rarely encrypted |

### Why This Happens

MPI requires passwordless SSH between all nodes. The "easy" solution:

```bash
# Generate key
ssh-keygen -t rsa -N "" -f ~/.ssh/id_rsa

# Copy to all nodes (or use shared home directory)
for node in node{1..100}; do
  ssh-copy-id $node
done

# Now mpirun works
mpirun -np 400 --hostfile nodes.txt ./simulation
```

Nobody rotates these keys because:
- MPI jobs would break
- Coordination across 1000s of nodes is hard
- "It's internal network, who cares"

---

## The Attack Surface

### Lateral Movement

```
Attacker compromises one compute node (CVE, container escape, etc.)
       │
       ▼
Reads ~/.ssh/id_rsa from disk or memory
       │
       ▼
SSHs to every other node in the cluster
       │
       ▼
Accesses all data, all GPUs, all jobs
```

### Real-World Scenarios

1. **Container escape**: User runs malicious container, escapes to host, reads SSH key
2. **Dependency attack**: Compromised pip/conda package exfiltrates ~/.ssh/
3. **Insider threat**: Disgruntled user copies keys before leaving
4. **Backup breach**: Old backup tape contains valid SSH keys
5. **Shared filesystem**: NFS server compromise exposes all user keys

### The Multi-Tenant Problem

AI cloud providers (CoreWeave, Lambda, Together AI) run multi-tenant on shared hardware:

```
┌─────────────────────────────────────────────┐
│              Physical GPU Node              │
├─────────────────────────────────────────────┤
│  Tenant A's VM    │    Tenant B's VM        │
│  (has SSH keys)   │    (has SSH keys)       │
│                   │                         │
│  Hypervisor/Container boundary             │
│  (if breached, keys exposed)               │
└─────────────────────────────────────────────┘
```

One tenant's compromise can lead to key theft affecting the whole cluster.

---

## Better Alternatives

### 1. SSH Certificates (Short-Lived)

Instead of static keys, use SSH certificates signed by a CA:

```bash
# User requests certificate (valid 8 hours)
ssh-keygen -s /path/to/ca_key -I user@job123 -n user -V +8h id_rsa.pub

# Certificate expires automatically
# No private key distribution needed
# CA can be hardware-protected (HSM)
```

**Pros**:
- Certificates expire
- Central revocation possible
- Audit trail of issuance

**Cons**:
- Still file-based (can be copied during validity window)
- Requires CA infrastructure
- MPI launchers need modification

**Tools**: Vault SSH, Smallstep, Netflix BLESS, Uber Pam-ussh

### 2. TPM-Bound SSH Keys

Private key never leaves the TPM chip:

```bash
# Generate key inside TPM (cannot be exported)
ssh-keygen -t ecdsa-sk -f ~/.ssh/id_ecdsa_sk

# Or with TPM2 directly
tpm2_create -C owner -G ecc -u key.pub -r key.priv
```

**Pros**:
- Key cannot be copied (hardware-bound)
- Theft of disk doesn't expose key
- Cryptographic proof of which machine holds key

**Cons**:
- Requires TPM on every node
- Key tied to specific hardware
- More complex provisioning

### 3. FIDO2/WebAuthn for SSH

OpenSSH 8.2+ supports FIDO2 security keys:

```bash
# Generate key bound to hardware token
ssh-keygen -t ed25519-sk -O resident -f ~/.ssh/id_ed25519_sk

# Requires physical touch to use
# Cannot be copied
```

**Pros**:
- Hardware-bound
- User presence verification (touch)
- Works with YubiKey, Titan, etc.

**Cons**:
- Requires hardware token per user
- Not practical for automated MPI launching
- Tokens are user-held, not node-held

### 4. Slurm + Munge (Status Quo "Better")

Slurm's munge provides job-scoped authentication:

```bash
# srun doesn't use SSH, uses munge tokens
srun -N 4 ./simulation

# Munge creates HMAC-signed credential
# Valid for specific user, specific time window
```

**Pros**:
- No SSH key distribution
- Time-limited tokens
- Integrated with job scheduler

**Cons**:
- Symmetric key (shared secret across cluster)
- One compromised node can forge tokens
- No hardware binding

### 5. Identity Fabric with DPU Enforcement (Our Proposal)

Combine TPM-bound credentials with DPU network enforcement:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Compute Node  │     │    BlueField    │     │  Destination    │
│   (TPM-bound    │────►│    DPU          │────►│  Node           │
│    credential)  │     │  (verifies at   │     │                 │
│                 │     │   line rate)    │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘

Flow:
1. Job starts, Slurm issues short-lived cert to job's nodes
2. Cert bound to node's TPM (cannot be copied)
3. MPI traffic carries identity in connection setup
4. DPU verifies cert before allowing traffic
5. Unauthorized nodes cannot communicate even on same network
```

**Pros**:
- Hardware-bound (TPM on compute, DICE on DPU)
- Short-lived (job-scoped certificates)
- Network-enforced (DPU blocks unauthorized traffic)
- Zero lateral movement (compromised node can't impersonate others)

**Cons**:
- Requires Beyond Identity + DPU integration
- New infrastructure component
- We need to build it

---

## Comparison Matrix

| Approach | Hardware Bound | Short-Lived | Network Enforced | Lateral Movement |
|----------|---------------|-------------|------------------|------------------|
| Static SSH keys | No | No | No | Full cluster |
| SSH certificates | No | Yes | No | During validity |
| TPM-bound SSH | Yes | Optional | No | None (that node) |
| Munge tokens | No | Yes | No | During validity |
| **Identity Fabric** | Yes | Yes | Yes | None |

---

## The Business Case

### For AI Cloud Providers

"Your competitors use static SSH keys. One container escape and an attacker has
access to every GPU in your cluster. We eliminate lateral movement at the
hardware layer."

### For Enterprises

"Your data scientists SSH into GPU clusters with keys stored in their home
directories. Those keys exist on every node, every backup, every container
image. We bind credentials to hardware so they can't be stolen."

### For Compliance

- **PCI-DSS**: Requires unique credentials, regular rotation
- **SOC2**: Requires access controls and audit trails
- **FedRAMP**: Requires hardware-based authentication for privileged access

Static SSH keys fail all of these. Hardware-bound, short-lived credentials pass.

---

## References

- [OpenSSH Certificate Authentication](https://www.openssh.com/txt/release-5.4)
- [TPM-based SSH with tpm2-pkcs11](https://github.com/tpm2-software/tpm2-pkcs11)
- [FIDO2 SSH Keys (OpenSSH 8.2)](https://www.openssh.com/txt/release-8.2)
- [Netflix BLESS](https://github.com/Netflix/bless)
- [Smallstep SSH](https://smallstep.com/docs/ssh/)
- [Slurm Munge Authentication](https://dun.github.io/munge/)
